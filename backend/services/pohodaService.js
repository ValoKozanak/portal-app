const axios = require('axios');
const xml2js = require('xml2js');

class PohodaService {
  constructor(config) {
    this.baseUrl = config.baseUrl; // e.g., 'http://localhost:8080'
    this.username = config.username;
    this.password = config.password;
    this.ico = config.ico; // Company ICO
    this.year = config.year; // Company year (IČO_ROK)
    this.xmlBuilder = new xml2js.Builder({
      rootName: 'dat:dataPack',
      headless: true,
      renderOpts: { pretty: true, indent: '  ' }
    });
  }

  // Helper method to make authenticated requests to POHODA mServer
  async makeRequest(endpoint, xmlData) {
    try {
      const response = await axios.post(`${this.baseUrl}/${endpoint}`, xmlData, {
        headers: {
          'Content-Type': 'application/xml',
          'Authorization': `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`
        },
        timeout: 30000
      });
      return response.data;
    } catch (error) {
      console.error('POHODA mServer request failed:', error.message);
      throw new Error(`POHODA integration error: ${error.message}`);
    }
  }

  // Create issued invoice in POHODA
  async createIssuedInvoice(invoiceData) {
    const xmlData = this.buildInvoiceXml(invoiceData);
    return await this.makeRequest('invoice', xmlData);
  }

  // Create received invoice in POHODA
  async createReceivedInvoice(invoiceData) {
    const xmlData = this.buildReceivedInvoiceXml(invoiceData);
    return await this.makeRequest('invoice', xmlData);
  }

  // Get invoices from POHODA
  async getInvoices(filters = {}) {
    const xmlData = this.buildInvoiceListRequest(filters);
    const response = await this.makeRequest('invoice', xmlData);
    return this.parseInvoiceListResponse(response);
  }

  // Create contact in POHODA
  async createContact(contactData) {
    const xmlData = this.buildContactXml(contactData);
    return await this.makeRequest('addressbook', xmlData);
  }

  // Get contacts from POHODA
  async getContacts(filters = {}) {
    const xmlData = this.buildContactListRequest(filters);
    const response = await this.makeRequest('addressbook', xmlData);
    return this.parseContactListResponse(response);
  }

  // Build XML for issued invoice
  buildInvoiceXml(invoiceData) {
    const invoiceXml = {
      'dat:dataPack': {
        '$': {
          'version': '2.0',
          'ico': this.year ? `${this.ico}_${this.year}` : this.ico,
          'application': 'Portal App',
          'note': 'Generated by Portal App'
        },
        'inv:invoice': {
          '$': {
            'version': '2.0'
          },
          'inv:invoiceHeader': {
            'inv:invoiceType': 'issued',
            'inv:symVar': invoiceData.symVar || '',
            'inv:date': invoiceData.date,
            'inv:dateTax': invoiceData.dateTax || invoiceData.date,
            'inv:dateAccounting': invoiceData.dateAccounting || invoiceData.date,
            'inv:partnerIdentity': {
              'typ:address': {
                'typ:company': invoiceData.customerName,
                'typ:ico': invoiceData.customerIco || '',
                'typ:dic': invoiceData.customerDic || '',
                'typ:street': invoiceData.customerAddress || '',
                'typ:city': invoiceData.customerCity || '',
                'typ:zip': invoiceData.customerZip || ''
              }
            },
            'inv:accounting': {
              'typ:ids': invoiceData.accountingId || '311'
            },
            'inv:classificationVAT': {
              'typ:ids': invoiceData.vatClassification || 'typ:classificationVATType'
            },
            'inv:classificationKVDPH': {
              'typ:ids': invoiceData.kvdphClassification || 'typ:classificationKVDPHType'
            },
            'inv:order': {
              'typ:numberOrder': invoiceData.orderNumber || '',
              'typ:dateOrder': invoiceData.orderDate || ''
            },
            'inv:paymentType': {
              'typ:ids': invoiceData.paymentType || 'typ:paymentType'
            },
            'inv:priceLevel': {
              'typ:ids': invoiceData.priceLevel || 'typ:priceLevel'
            },
            'inv:currency': {
              'typ:ids': invoiceData.currency || 'CZK'
            },
            'inv:rate': invoiceData.rate || '1',
            'inv:dateDelivery': invoiceData.dateDelivery || invoiceData.date
          },
          'inv:invoiceDetail': {
            'inv:invoiceItem': invoiceData.items.map(item => ({
              'inv:text': item.description,
              'inv:quantity': item.quantity,
              'inv:unit': item.unit || 'ks',
              'inv:coefficient': item.coefficient || '1',
              'inv:payVAT': item.payVat !== false,
              'inv:rateVAT': item.rateVat || 'high',
              'inv:discountPercentage': item.discountPercentage || '0',
              'inv:homeCurrency': {
                'typ:unitPrice': item.unitPrice,
                'typ:price': item.totalPrice,
                'typ:priceVAT': item.priceVat,
                'typ:priceSum': item.priceSum
              }
            }))
          },
          'inv:invoiceSummary': {
            'inv:roundingDocument': 'math2one',
            'inv:roundingVAT': 'math2one',
            'inv:calculateVAT': true,
            'inv:homeCurrency': {
              'typ:priceNone': invoiceData.priceNone || '0',
              'typ:priceLow': invoiceData.priceLow || '0',
              'typ:priceLowVAT': invoiceData.priceLowVat || '0',
              'typ:priceLowSum': invoiceData.priceLowSum || '0',
              'typ:priceLowSumVAT': invoiceData.priceLowSumVat || '0',
              'typ:priceHigh': invoiceData.priceHigh || '0',
              'typ:priceHighVAT': invoiceData.priceHighVat || '0',
              'typ:priceHighSum': invoiceData.priceHighSum || '0',
              'typ:priceHighSumVAT': invoiceData.priceHighSumVat || '0',
              'typ:price3': invoiceData.price3 || '0',
              'typ:price3VAT': invoiceData.price3Vat || '0',
              'typ:price3Sum': invoiceData.price3Sum || '0',
              'typ:price3SumVAT': invoiceData.price3SumVat || '0',
              'typ:roundingDocument': invoiceData.roundingDocument || '0'
            }
          }
        }
      }
    };

    return this.xmlBuilder.buildObject(invoiceXml);
  }

  // Build XML for received invoice
  buildReceivedInvoiceXml(invoiceData) {
    const invoiceXml = {
      'dat:dataPack': {
        '$': {
          'version': '2.0',
          'ico': this.year ? `${this.ico}_${this.year}` : this.ico,
          'application': 'Portal App',
          'note': 'Generated by Portal App'
        },
        'inv:invoice': {
          '$': {
            'version': '2.0'
          },
          'inv:invoiceHeader': {
            'inv:invoiceType': 'received',
            'inv:symVar': invoiceData.symVar || '',
            'inv:date': invoiceData.date,
            'inv:dateTax': invoiceData.dateTax || invoiceData.date,
            'inv:dateAccounting': invoiceData.dateAccounting || invoiceData.date,
            'inv:partnerIdentity': {
              'typ:address': {
                'typ:company': invoiceData.supplierName,
                'typ:ico': invoiceData.supplierIco || '',
                'typ:dic': invoiceData.supplierDic || '',
                'typ:street': invoiceData.supplierAddress || '',
                'typ:city': invoiceData.supplierCity || '',
                'typ:zip': invoiceData.supplierZip || ''
              }
            },
            'inv:accounting': {
              'typ:ids': invoiceData.accountingId || '321'
            },
            'inv:classificationVAT': {
              'typ:ids': invoiceData.vatClassification || 'typ:classificationVATType'
            },
            'inv:classificationKVDPH': {
              'typ:ids': invoiceData.kvdphClassification || 'typ:classificationKVDPHType'
            },
            'inv:paymentType': {
              'typ:ids': invoiceData.paymentType || 'typ:paymentType'
            },
            'inv:currency': {
              'typ:ids': invoiceData.currency || 'CZK'
            },
            'inv:rate': invoiceData.rate || '1',
            'inv:dateDelivery': invoiceData.dateDelivery || invoiceData.date
          },
          'inv:invoiceDetail': {
            'inv:invoiceItem': invoiceData.items.map(item => ({
              'inv:text': item.description,
              'inv:quantity': item.quantity,
              'inv:unit': item.unit || 'ks',
              'inv:coefficient': item.coefficient || '1',
              'inv:payVAT': item.payVat !== false,
              'inv:rateVAT': item.rateVat || 'high',
              'inv:discountPercentage': item.discountPercentage || '0',
              'inv:homeCurrency': {
                'typ:unitPrice': item.unitPrice,
                'typ:price': item.totalPrice,
                'typ:priceVAT': item.priceVat,
                'typ:priceSum': item.priceSum
              }
            }))
          },
          'inv:invoiceSummary': {
            'inv:roundingDocument': 'math2one',
            'inv:roundingVAT': 'math2one',
            'inv:calculateVAT': true,
            'inv:homeCurrency': {
              'typ:priceNone': invoiceData.priceNone || '0',
              'typ:priceLow': invoiceData.priceLow || '0',
              'typ:priceLowVAT': invoiceData.priceLowVat || '0',
              'typ:priceLowSum': invoiceData.priceLowSum || '0',
              'typ:priceLowSumVAT': invoiceData.priceLowSumVat || '0',
              'typ:priceHigh': invoiceData.priceHigh || '0',
              'typ:priceHighVAT': invoiceData.priceHighVat || '0',
              'typ:priceHighSum': invoiceData.priceHighSum || '0',
              'typ:priceHighSumVAT': invoiceData.priceHighSumVat || '0',
              'typ:price3': invoiceData.price3 || '0',
              'typ:price3VAT': invoiceData.price3Vat || '0',
              'typ:price3Sum': invoiceData.price3Sum || '0',
              'typ:price3SumVAT': invoiceData.price3SumVat || '0',
              'typ:roundingDocument': invoiceData.roundingDocument || '0'
            }
          }
        }
      }
    };

    return this.xmlBuilder.buildObject(invoiceXml);
  }

  // Build XML for invoice list request
  buildInvoiceListRequest(filters) {
    const requestXml = {
              'dat:dataPack': {
          '$': {
            'version': '2.0',
            'ico': this.year ? `${this.ico}_${this.year}` : this.ico,
            'application': 'Portal App',
            'note': 'Invoice list request'
          },
        'lst:listInvoiceRequest': {
          '$': {
            'version': '2.0'
          },
          'lst:requestInvoice': {
            'lst:filter': {
              'lst:dateFrom': filters.dateFrom || '',
              'lst:dateTo': filters.dateTo || '',
              'lst:invoiceType': filters.invoiceType || 'issued',
              'lst:storno': filters.storno || false
            }
          }
        }
      }
    };

    return this.xmlBuilder.buildObject(requestXml);
  }

  // Parse invoice list response
  async parseInvoiceListResponse(xmlResponse) {
    try {
      const parser = new xml2js.Parser({ explicitArray: false });
      const result = await parser.parseStringPromise(xmlResponse);
      
      console.log('Parsed invoice response:', JSON.stringify(result, null, 2));
      
      if (result['dat:dataPack'] && result['dat:dataPack']['lst:listInvoice']) {
        const invoices = result['dat:dataPack']['lst:listInvoice']['lst:invoice'];
        if (invoices) {
          return Array.isArray(invoices) ? invoices : [invoices];
        }
      }
      
      return [];
    } catch (error) {
      console.error('Error parsing invoice list response:', error);
      return [];
    }
  }

  // Build XML for contact
  buildContactXml(contactData) {
    const contactXml = {
      'dat:dataPack': {
        '$': {
          'version': '2.0',
          'ico': this.year ? `${this.ico}_${this.year}` : this.ico,
          'application': 'Portal App',
          'note': 'Generated by Portal App'
        },
        'adb:addressbook': {
          '$': {
            'version': '2.0'
          },
          'adb:addressbookHeader': {
            'adb:name': contactData.name,
            'adb:ico': contactData.ico || '',
            'adb:dic': contactData.dic || '',
            'adb:street': contactData.street || '',
            'adb:city': contactData.city || '',
            'adb:zip': contactData.zip || '',
            'adb:phone': contactData.phone || '',
            'adb:mobil': contactData.mobile || '',
            'adb:email': contactData.email || '',
            'adb:www': contactData.www || '',
            'adb:note': contactData.note || ''
          }
        }
      }
    };

    return this.xmlBuilder.buildObject(contactXml);
  }

  // Build XML for contact list request
  buildContactListRequest(filters) {
    const requestXml = {
              'dat:dataPack': {
          '$': {
            'version': '2.0',
            'ico': this.year ? `${this.ico}_${this.year}` : this.ico,
            'application': 'Portal App',
            'note': 'Contact list request'
          },
        'lst:listAddressBookRequest': {
          '$': {
            'version': '2.0'
          },
          'lst:requestAddressBook': {
            'lst:filter': {
              'lst:name': filters.name || '',
              'lst:ico': filters.ico || ''
            }
          }
        }
      }
    };

    return this.xmlBuilder.buildObject(requestXml);
  }

  // Parse contact list response
  async parseContactListResponse(xmlResponse) {
    try {
      const parser = new xml2js.Parser({ explicitArray: false });
      const result = await parser.parseStringPromise(xmlResponse);
      
      if (result['dat:dataPack'] && result['dat:dataPack']['lst:listAddressBook']) {
        const contacts = result['dat:dataPack']['lst:listAddressBook']['lst:addressbook'];
        return Array.isArray(contacts) ? contacts : [contacts];
      }
      
      return [];
    } catch (error) {
      console.error('Error parsing contact list response:', error);
      return [];
    }
  }

  // Parse invoice list response
  async parseInvoiceListResponse(xmlResponse) {
    try {
      const parser = new xml2js.Parser({ explicitArray: false });
      const result = await parser.parseStringPromise(xmlResponse);
      
      console.log('Parsed invoice response:', JSON.stringify(result, null, 2));
      
      if (result['dat:dataPack'] && result['dat:dataPack']['lst:listInvoice']) {
        const invoices = result['dat:dataPack']['lst:listInvoice']['lst:invoice'];
        if (invoices) {
          return Array.isArray(invoices) ? invoices : [invoices];
        }
      }
      
      return [];
    } catch (error) {
      console.error('Error parsing invoice list response:', error);
      return [];
    }
  }

  // Test connection to POHODA mServer
  async testConnection() {
    try {
      console.log('Testing POHODA connection to:', this.baseUrl);
      
      // Najprv skontrolujeme, či je server dostupný
      const serverResponse = await axios.get(this.baseUrl, {
        timeout: 10000,
        headers: {
          'Authorization': `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`
        }
      });
      
      console.log('POHODA mServer response status:', serverResponse.status);
      console.log('POHODA mServer response data:', serverResponse.data);
      
      // Ak server odpovedá, považujeme to za úspešné
      return { 
        success: true, 
        message: 'POHODA mServer je dostupný a reaguje',
        serverInfo: serverResponse.data
      };
    } catch (error) {
      console.error('POHODA test connection error:', error.message);
      
      // Ak je to 404, znamená to, že server beží, ale endpoint neexistuje
      if (error.response && error.response.status === 404) {
        return { 
          success: true, 
          message: 'POHODA mServer je dostupný (404 znamená, že endpoint neexistuje, ale server reaguje)',
          warning: 'Endpoint neexistuje, ale server beží'
        };
      }
      
      return { success: false, error: error.message };
    }
  }
}

module.exports = PohodaService;
